# üß© LeetCode Solutions Repository

Welcome to my LeetCode solutions repository! 

LeetCode is a fantastic way to test your problem-solving skills while diving deep into the world of data structures and algorithms. It teaches you not only how to implement them but most importantly when to use them. I've recently fallen into the delightful trap of these puzzles, and they have been juicing my brain out! 

As I navigated through the platform, I wanted to keep a neat track of all the problems I've solved so far to track my progress and improvement. What better way to do this than by creating a GitHub repository? This repo contains my humble solutions to the puzzles I've tackled up to now, all in one convenient place. 

Whether you‚Äôre gearing up for epic coding battles (a.k.a. interviews) or just leveling up your coding skills, I hope you find these solutions helpful. Feel free to drop any suggestions to improve them! Happy coding! 


## üìÇ Repository Structure

The repository is organized into categories, each containing Java files for solving different types of problems. Below is a detailed structure:

- **`LeetCode-Solutions/`**
  - **`BinarySearch/`**
    - `...`
  - **`Dynamic_Programming/`**
    - `...`
  - **`HashingAndArrays/`**
    - `...`
  - **`Greedy/`**
    - `...`
  - **`SlidingWindow/`**
    - `...`
  - **`StacksAndQueues/`**
    - `...`
  - **`TreesAndGraphs/`**
    - `...`
  - **`TwoPointers/`**
    - `...`


## üìö Directory Structure Overview

- **Binary Search**: Solutions involving binary search algorithms. Binary search efficiently finds a target value within a sorted array by repeatedly dividing the search interval in half. It decreases the time complexity compared to linear search.

- **Dynamic Programming**: Problems solved using dynamic programming techniques. Dynamic programming breaks down complex problems into simpler overlapping subproblems and stores results to avoid redundant computations, often using memoization or tabulation.

- **Hashing and Arrays**: Solutions utilizing hashing and array operations. Hashing involves mapping data to a fixed-size table (hash table) for efficient retrieval, while arrays are fundamental data structures used for storing elements of the same data type, offering fast access based on index.

- **Greedy**: Problems approached with greedy algorithms. Greedy algorithms make locally optimal choices at each stage with the aim of finding a global optimum solution, often used in optimization problems.

- **Sliding Window**: Solutions that employ the sliding window technique. Sliding window performs operations over a fixed-size window in a linear sequence of elements, optimizing operations that would otherwise require O(n^2) complexity.

- **Stacks and Queues**: Problems using stack and queue data structures. Stacks (Last In, First Out) and queues (First In, First Out) manage data with specific insertion and deletion rules. Stacks are used for last-in, first-out access, while queues maintain order and are typically used for breadth-first traversal.

- **Trees and Graphs**: Solutions for tree and graph-related problems. Trees are hierarchical data structures with nodes and edges, while graphs represent networks of nodes (vertices) and edges connecting them, offering versatile structures for modeling relationships.

- **Two Pointers**: Problems solved using the two-pointer technique. Two pointers involve iterating through a list with two references or indices, often converging towards a solution or optimizing a linear operation, useful in scenarios like searching or partitioning arrays.


## üõ†Ô∏è Tools and Technologies

- **Language**: Java
- **Platform**: LeetCode
- **IDE**: Any Java-compatible IDE (e.g., IntelliJ IDEA (the one i personally use and prefer, Eclipse, VSCode...)

## üìß Contact

Feel free to reach out if you have any questions or suggestions:

- **Email**: alabadila.malai1@gmail.com
- **GitHub**: [Alabadilaa](https://github.com/Alabadilaa)
- **LeetCode**: [Alabadila](https://leetcode.com/u/Alabadila/)